---
title: Frontend Practices
description: Component architecture, styling patterns, and best practices for the web application
---

## Component Organization

Components are organized by feature in the `apps/web/src/components` directory:

```
components/
├── auth/           # Authentication components
│   ├── oauth-login-form.tsx
│   └── user-menu.tsx
├── chat/           # Chat feature components
│   ├── chat-bubble.tsx
│   └── settings-menu.tsx
├── layout/         # Layout and navigation
│   ├── header.tsx
│   ├── mode-toggle.tsx
│   └── theme-provider.tsx
├── ui/             # Reusable base components
│   ├── badge.tsx
│   ├── button.tsx
│   ├── combobox.tsx
│   ├── dropdown-menu.tsx
│   ├── menu.tsx
│   ├── popover.tsx
│   ├── skeleton.tsx
│   ├── textarea.tsx
│   ├── toast.tsx
│   └── loader.tsx
└── providers.tsx   # App-wide providers
```

## Styling with Tailwind Variants

We use [tailwind-variants](https://www.tailwind-variants.org/) for component styling with DaisyUI classes:

```tsx
import { tv, type VariantProps } from "tailwind-variants";

const buttonStyles = tv({
  base: "btn",
  variants: {
    variant: {
      primary: "btn-primary",
      secondary: "btn-secondary",
      ghost: "btn-ghost",
    },
    size: {
      sm: "btn-sm",
      default: "btn-md",
      lg: "btn-lg",
    },
  },
  defaultVariants: {
    variant: "primary",
    size: "default",
  },
});

type ButtonVariants = VariantProps<typeof buttonStyles>;
```

### Using Slots for Complex Components

For components with multiple styled parts, use the `slots` pattern:

```tsx
const menuStyles = tv({
  slots: {
    menu: "flex flex-col w-full bg-base-100 p-2",
    item: "rounded-btn px-3 py-2 cursor-pointer outline-none transition-colors data-focused:bg-base-200",
    separator: "divider my-1",
  },
  variants: {
    size: {
      sm: { menu: "menu-sm" },
      default: { menu: "menu-md" },
      lg: { menu: "menu-lg" },
    },
  },
});

// Usage
const styles = menuStyles({ size: "sm" });
<ul className={styles.menu()}>
  <li className={styles.item()}>Item</li>
</ul>
```

## React Aria Components

We use [React Aria Components](https://react-spectrum.adobe.com/react-aria/index.html) for accessible, unstyled primitives:

```tsx
import {
  Button as AriaButton,
  type ButtonProps as AriaButtonProps,
} from "react-aria-components";

interface ButtonProps extends AriaButtonProps, ButtonVariants {
  className?: string;
}

function Button({ className, variant, size, ...props }: ButtonProps) {
  return (
    <AriaButton
      className={buttonStyles({ variant, size, className })}
      {...props}
    />
  );
}
```

### Key React Aria Patterns

1. **Popover with optional Dialog wrapper** - Use `withDialog={false}` for menus that handle their own focus:

```tsx
// For dropdown menus (no Dialog wrapper needed)
<Popover withDialog={false} className="p-0">
  <Menu>...</Menu>
</Popover>

// For general popovers (Dialog wrapper for focus management)
<Popover>
  <div>Popover content</div>
</Popover>
```

2. **Shared base styles** - Export base styles for consistency:

```tsx
// popover.tsx
export const popoverBaseStyles =
  "rounded-box border border-base-300 bg-base-100 shadow-lg outline-none entering:animate-in entering:fade-in entering:zoom-in-95 exiting:animate-out exiting:fade-out exiting:zoom-out-95";
```

3. **Menu components** - Use `Menu`/`MenuItem` for dropdown menus, `ListBoxMenu`/`ListBoxMenuItem` for combobox/select:

```tsx
// Dropdown menu
<Menu>
  <MenuItem onAction={() => {}}>Action</MenuItem>
</Menu>

// Combobox listbox
<ListBoxMenu items={items}>
  {(item) => <ListBoxMenuItem id={item.id}>{item.name}</ListBoxMenuItem>}
</ListBoxMenu>
```

## DaisyUI Integration

We use [DaisyUI](https://daisyui.com/) for component styling. Key patterns:

### Theme Support

```tsx
// theme-provider.tsx uses next-themes with data-theme attribute
<ThemeProvider
  attribute="data-theme"
  defaultTheme="system"
  enableSystem
  themes={["light", "dark", "cupcake", "forest"]}
>
  {children}
</ThemeProvider>
```

### Custom Variant for Dark Mode

```css
/* index.css */
@custom-variant dark (&:where([data-theme=dark], [data-theme=dark] *));
```

## State Management

### React Context for Feature State

```tsx
// contexts/dataset-context.tsx
import { createContext, useContext, useState, useCallback } from "react";

interface DatasetContextValue {
  selectedDatasets: Dataset[];
  addDataset: (dataset: Dataset) => void;
  removeDataset: (id: string) => void;
}

const DatasetContext = createContext<DatasetContextValue | null>(null);

export function useDatasets() {
  const context = useContext(DatasetContext);
  if (!context) {
    throw new Error("useDatasets must be used within DatasetProvider");
  }
  return context;
}
```

### React Stately for Async Data

Use `useAsyncList` for async search/filter operations:

```tsx
import { useAsyncList } from "react-stately";

const list = useAsyncList<Dataset>({
  load: async ({ signal, filterText }) => {
    const results = await orpc.searchDatasets.call(
      { query: filterText ?? "" },
      { signal }
    );
    return { items: results };
  },
});

// Use in ComboBox
<ComboBox
  items={list.items}
  inputValue={list.filterText}
  onInputChange={list.setFilterText}
  isLoading={list.isLoading}
/>
```

## Hydration Safety

For components that differ between SSR and client, use a `mounted` state:

```tsx
function UserMenu() {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return <Skeleton className="h-10 w-10 rounded-full" />;
  }

  return <DropdownMenu>...</DropdownMenu>;
}
```

## File Naming Conventions

- Components: `kebab-case.tsx` (e.g., `chat-bubble.tsx`)
- Context files: `kebab-case.tsx` in `contexts/` directory
- Utility files: `kebab-case.ts` in `utils/` directory
- Types shared across packages: Define in `@momentum/schemas`
